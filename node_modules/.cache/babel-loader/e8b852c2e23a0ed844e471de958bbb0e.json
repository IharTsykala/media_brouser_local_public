{"ast":null,"code":"\"use strict\";\n\nvar filter = require('unist-util-filter');\n\nvar visit = require('unist-util-visit-parents');\n\nvar NodeMap = require('./map');\n\nfunction lineNumberify(ast) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    lineNumber: 1\n  };\n  return ast.reduce(function (result, node) {\n    var lineStart = context.lineNumber;\n\n    if (node.type === 'text') {\n      if (node.value.indexOf('\\n') === -1) {\n        node.lineStart = lineStart;\n        node.lineEnd = lineStart;\n        result.nodes.push(node);\n        return result;\n      }\n\n      var lines = node.value.split('\\n');\n\n      for (var i = 0; i < lines.length; i++) {\n        var lineNum = i === 0 ? context.lineNumber : ++context.lineNumber;\n        result.nodes.push({\n          type: 'text',\n          value: i === lines.length - 1 ? lines[i] : \"\".concat(lines[i], \"\\n\"),\n          lineStart: lineNum,\n          lineEnd: lineNum\n        });\n      }\n\n      result.lineNumber = context.lineNumber;\n      return result;\n    }\n\n    if (node.children) {\n      var processed = lineNumberify(node.children, context);\n      var firstChild = processed.nodes[0];\n      var lastChild = processed.nodes[processed.nodes.length - 1];\n      node.lineStart = firstChild ? firstChild.lineStart : lineStart;\n      node.lineEnd = lastChild ? lastChild.lineEnd : lineStart;\n      node.children = processed.nodes;\n      result.lineNumber = processed.lineNumber;\n      result.nodes.push(node);\n      return result;\n    }\n\n    result.nodes.push(node);\n    return result;\n  }, {\n    nodes: [],\n    lineNumber: context.lineNumber\n  });\n}\n\nfunction unwrapLine(markerLine, nodes) {\n  var tree = {\n    type: 'root',\n    children: nodes\n  };\n  var headMap = new NodeMap();\n  var lineMap = new NodeMap();\n  var tailMap = new NodeMap();\n  var cloned = [];\n\n  function addCopy(map, node, ancestors) {\n    cloned.push(node);\n    ancestors.forEach(function (ancestor) {\n      if (!map.has(ancestor)) {\n        map.set(ancestor, Object.assign({}, ancestor, {\n          children: []\n        }));\n\n        if (ancestor !== tree) {\n          cloned.push(ancestor);\n        }\n      }\n    });\n    var i = ancestors.length;\n\n    while (i--) {\n      var ancestor = map.get(ancestors[i]);\n      var child = ancestors[i + 1];\n      var leaf = map.get(child) || node;\n\n      if (ancestor.children.indexOf(leaf) === -1) {\n        ancestor.children.push(leaf);\n      }\n    }\n  }\n\n  visit(tree, function (node, ancestors) {\n    if (node.children) {\n      return;\n    } // These nodes are on previous lines, but nested within the same structure\n\n\n    if (node.lineStart < markerLine) {\n      addCopy(headMap, node, ancestors);\n      return;\n    } // These nodes are on the target line\n\n\n    if (node.lineStart === markerLine) {\n      addCopy(lineMap, node, ancestors);\n      return;\n    } // If we have shared ancestors with some of the cloned elements,\n    // create another tree of the remaining nodes\n\n\n    if (node.lineEnd > markerLine && cloned.some(function (clone) {\n      return ancestors.indexOf(clone) !== -1;\n    })) {\n      addCopy(tailMap, node, ancestors);\n    }\n  }); // Get the remaining nodes - the ones who were not part of the same tree\n\n  var filtered = filter(tree, function (node) {\n    return cloned.indexOf(node) === -1;\n  });\n\n  var getChildren = function getChildren(map) {\n    var rootNode = map.get(tree);\n\n    if (!rootNode) {\n      return [];\n    }\n\n    visit(rootNode, function (leaf, ancestors) {\n      if (leaf.children) {\n        leaf.lineStart = 0;\n        leaf.lineEnd = 0;\n        return;\n      }\n\n      ancestors.forEach(function (ancestor) {\n        ancestor.lineStart = Math.max(ancestor.lineStart, leaf.lineStart);\n        ancestor.lineEnd = Math.max(ancestor.lineEnd, leaf.lineEnd);\n      });\n    });\n    return rootNode.children;\n  };\n\n  var merged = [].concat(getChildren(headMap), getChildren(lineMap), getChildren(tailMap), filtered ? filtered.children : []);\n  headMap.clear();\n  lineMap.clear();\n  tailMap.clear();\n  return merged;\n}\n\nfunction wrapBatch(children, marker, options) {\n  var className = marker.className || 'refractor-marker';\n  return {\n    type: 'element',\n    tagName: marker.component || 'div',\n    properties: marker.component ? Object.assign({}, options, {\n      className: className\n    }) : {\n      className: className\n    },\n    children: children,\n    lineStart: marker.line,\n    lineEnd: children[children.length - 1].lineEnd,\n    isMarker: true\n  };\n}\n\nfunction wrapLines(treeNodes, markers, options) {\n  if (markers.length === 0 || treeNodes.length === 0) {\n    return treeNodes;\n  }\n\n  var ast = markers.reduce(function (acc, marker) {\n    return unwrapLine(marker.line, acc);\n  }, treeNodes); // Container for the new AST\n\n  var wrapped = []; // Note: Markers are already sorted by line number (ascending)\n\n  var astIndex = 0;\n\n  for (var m = 0; m < markers.length; m++) {\n    var marker = markers[m]; // Start by eating all AST nodes with line numbers up to the given marker\n\n    for (var node = ast[astIndex]; node && node.lineEnd < marker.line; node = ast[++astIndex]) {\n      wrapped.push(node);\n    } // Now proceed to find all _contiguous_ nodes on the same line\n\n\n    var batch = [];\n\n    for (var _node = ast[astIndex]; _node && _node.lineEnd === marker.line; _node = ast[++astIndex]) {\n      batch.push(_node);\n    } // Now add that batch, if we have anything\n\n\n    if (batch.length > 0) {\n      wrapped.push(wrapBatch(batch, marker, options));\n    }\n  } // Now add the remaining AST nodes\n\n\n  while (astIndex < ast.length) {\n    wrapped.push(ast[astIndex++]);\n  }\n\n  return wrapped;\n}\n\nfunction addMarkers(ast, options) {\n  var markers = options.markers.map(function (marker) {\n    return marker.line ? marker : {\n      line: marker\n    };\n  }).sort(function (nodeA, nodeB) {\n    return nodeA.line - nodeB.line;\n  });\n  var numbered = lineNumberify(ast).nodes;\n  return wrapLines(numbered, markers, options);\n}\n\nmodule.exports = addMarkers;","map":{"version":3,"sources":["../src/addMarkers.js"],"names":["filter","require","visit","NodeMap","context","lineNumber","lineStart","node","result","lines","i","lineNum","type","value","lineEnd","processed","lineNumberify","firstChild","lastChild","nodes","tree","children","headMap","lineMap","tailMap","cloned","ancestors","map","ancestor","child","leaf","addCopy","filtered","getChildren","rootNode","Math","merged","className","marker","tagName","properties","isMarker","markers","treeNodes","ast","unwrapLine","wrapped","astIndex","m","batch","wrapBatch","line","nodeA","nodeB","numbered","wrapLines","module"],"mappings":";;AAAA,IAAMA,MAAM,GAAGC,OAAO,CAAtB,mBAAsB,CAAtB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAArB,0BAAqB,CAArB;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAvB,OAAuB,CAAvB;;AAEA,SAAA,aAAA,CAAA,GAAA,EAAuD;AAAA,MAA3BG,OAA2B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAjB;AAACC,IAAAA,UAAU,EAAE;AAAb,GAAiB;AACrD,SAAO,GAAG,CAAH,MAAA,CACL,UAAA,MAAA,EAAA,IAAA,EAAkB;AAChB,QAAMC,SAAS,GAAGF,OAAO,CAAzB,UAAA;;AAEA,QAAIG,IAAI,CAAJA,IAAAA,KAAJ,MAAA,EAA0B;AACxB,UAAIA,IAAI,CAAJA,KAAAA,CAAAA,OAAAA,CAAAA,IAAAA,MAA6B,CAAjC,CAAA,EAAqC;AACnCA,QAAAA,IAAI,CAAJA,SAAAA,GAAAA,SAAAA;AACAA,QAAAA,IAAI,CAAJA,OAAAA,GAAAA,SAAAA;AACAC,QAAAA,MAAM,CAANA,KAAAA,CAAAA,IAAAA,CAAAA,IAAAA;AACA,eAAA,MAAA;AACD;;AAED,UAAMC,KAAK,GAAGF,IAAI,CAAJA,KAAAA,CAAAA,KAAAA,CAAd,IAAcA,CAAd;;AACA,WAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGD,KAAK,CAAzB,MAAA,EAAkCC,CAAlC,EAAA,EAAuC;AACrC,YAAMC,OAAO,GAAGD,CAAC,KAADA,CAAAA,GAAUN,OAAO,CAAjBM,UAAAA,GAA+B,EAAEN,OAAO,CAAxD,UAAA;AACAI,QAAAA,MAAM,CAANA,KAAAA,CAAAA,IAAAA,CAAkB;AAChBI,UAAAA,IAAI,EADY,MAAA;AAEhBC,UAAAA,KAAK,EAAEH,CAAC,KAAKD,KAAK,CAALA,MAAAA,GAANC,CAAAA,GAAyBD,KAAK,CAA9BC,CAA8B,CAA9BA,GAAAA,GAAAA,MAAAA,CAAuCD,KAAK,CAA5CC,CAA4C,CAA5CA,EAFS,IAETA,CAFS;AAGhBJ,UAAAA,SAAS,EAHO,OAAA;AAIhBQ,UAAAA,OAAO,EAAEH;AAJO,SAAlBH;AAMD;;AAEDA,MAAAA,MAAM,CAANA,UAAAA,GAAoBJ,OAAO,CAA3BI,UAAAA;AACA,aAAA,MAAA;AACD;;AAED,QAAID,IAAI,CAAR,QAAA,EAAmB;AACjB,UAAMQ,SAAS,GAAGC,aAAa,CAACT,IAAI,CAAL,QAAA,EAA/B,OAA+B,CAA/B;AACA,UAAMU,UAAU,GAAGF,SAAS,CAATA,KAAAA,CAAnB,CAAmBA,CAAnB;AACA,UAAMG,SAAS,GAAGH,SAAS,CAATA,KAAAA,CAAgBA,SAAS,CAATA,KAAAA,CAAAA,MAAAA,GAAlC,CAAkBA,CAAlB;AACAR,MAAAA,IAAI,CAAJA,SAAAA,GAAiBU,UAAU,GAAGA,UAAU,CAAb,SAAA,GAA3BV,SAAAA;AACAA,MAAAA,IAAI,CAAJA,OAAAA,GAAeW,SAAS,GAAGA,SAAS,CAAZ,OAAA,GAAxBX,SAAAA;AACAA,MAAAA,IAAI,CAAJA,QAAAA,GAAgBQ,SAAS,CAAzBR,KAAAA;AACAC,MAAAA,MAAM,CAANA,UAAAA,GAAoBO,SAAS,CAA7BP,UAAAA;AACAA,MAAAA,MAAM,CAANA,KAAAA,CAAAA,IAAAA,CAAAA,IAAAA;AACA,aAAA,MAAA;AACD;;AAEDA,IAAAA,MAAM,CAANA,KAAAA,CAAAA,IAAAA,CAAAA,IAAAA;AACA,WAAA,MAAA;AAxCG,GAAA,EA0CL;AAACW,IAAAA,KAAK,EAAN,EAAA;AAAYd,IAAAA,UAAU,EAAED,OAAO,CAACC;AAAhC,GA1CK,CAAP;AA4CD;;AAED,SAAA,UAAA,CAAA,UAAA,EAAA,KAAA,EAAuC;AACrC,MAAMe,IAAI,GAAG;AAACR,IAAAA,IAAI,EAAL,MAAA;AAAeS,IAAAA,QAAQ,EAAEF;AAAzB,GAAb;AAEA,MAAMG,OAAO,GAAG,IAAhB,OAAgB,EAAhB;AACA,MAAMC,OAAO,GAAG,IAAhB,OAAgB,EAAhB;AACA,MAAMC,OAAO,GAAG,IAAhB,OAAgB,EAAhB;AACA,MAAMC,MAAM,GAAZ,EAAA;;AAEA,WAAA,OAAA,CAAA,GAAA,EAAA,IAAA,EAAA,SAAA,EAAuC;AACrCA,IAAAA,MAAM,CAANA,IAAAA,CAAAA,IAAAA;AAEAC,IAAAA,SAAS,CAATA,OAAAA,CAAkB,UAAA,QAAA,EAAc;AAC9B,UAAI,CAACC,GAAG,CAAHA,GAAAA,CAAL,QAAKA,CAAL,EAAwB;AACtBA,QAAAA,GAAG,CAAHA,GAAAA,CAAAA,QAAAA,EAAkB,MAAM,CAAN,MAAA,CAAA,EAAA,EAAA,QAAA,EAA4B;AAACN,UAAAA,QAAQ,EAAE;AAAX,SAA5B,CAAlBM;;AAEA,YAAIC,QAAQ,KAAZ,IAAA,EAAuB;AACrBH,UAAAA,MAAM,CAANA,IAAAA,CAAAA,QAAAA;AACD;AACF;AAPHC,KAAAA;AAUA,QAAIhB,CAAC,GAAGgB,SAAS,CAAjB,MAAA;;AACA,WAAOhB,CAAP,EAAA,EAAY;AACV,UAAMkB,QAAQ,GAAGD,GAAG,CAAHA,GAAAA,CAAQD,SAAS,CAAlC,CAAkC,CAAjBC,CAAjB;AACA,UAAME,KAAK,GAAGH,SAAS,CAAChB,CAAC,GAAzB,CAAuB,CAAvB;AACA,UAAMoB,IAAI,GAAGH,GAAG,CAAHA,GAAAA,CAAAA,KAAAA,KAAb,IAAA;;AACA,UAAIC,QAAQ,CAARA,QAAAA,CAAAA,OAAAA,CAAAA,IAAAA,MAAoC,CAAxC,CAAA,EAA4C;AAC1CA,QAAAA,QAAQ,CAARA,QAAAA,CAAAA,IAAAA,CAAAA,IAAAA;AACD;AACF;AACF;;AAED1B,EAAAA,KAAK,CAAA,IAAA,EAAO,UAAA,IAAA,EAAA,SAAA,EAAqB;AAC/B,QAAIK,IAAI,CAAR,QAAA,EAAmB;AACjB;AAF6B,KAAA,CAK/B;;;AACA,QAAIA,IAAI,CAAJA,SAAAA,GAAJ,UAAA,EAAiC;AAC/BwB,MAAAA,OAAO,CAAA,OAAA,EAAA,IAAA,EAAPA,SAAO,CAAPA;AACA;AAR6B,KAAA,CAW/B;;;AACA,QAAIxB,IAAI,CAAJA,SAAAA,KAAJ,UAAA,EAAmC;AACjCwB,MAAAA,OAAO,CAAA,OAAA,EAAA,IAAA,EAAPA,SAAO,CAAPA;AACA;AAd6B,KAAA,CAiB/B;AACA;;;AACA,QAAIxB,IAAI,CAAJA,OAAAA,GAAAA,UAAAA,IAA6B,MAAM,CAAN,IAAA,CAAY,UAAA,KAAA,EAAA;AAAA,aAAWmB,SAAS,CAATA,OAAAA,CAAAA,KAAAA,MAA6B,CAAxC,CAAA;AAA7C,KAAiC,CAAjC,EAA0F;AACxFK,MAAAA,OAAO,CAAA,OAAA,EAAA,IAAA,EAAPA,SAAO,CAAPA;AACD;AArDkC,GAgChC,CAAL7B,CAhCqC,CAwDrC;;AACA,MAAM8B,QAAQ,GAAGhC,MAAM,CAAA,IAAA,EAAO,UAAA,IAAA,EAAA;AAAA,WAAUyB,MAAM,CAANA,OAAAA,CAAAA,IAAAA,MAAyB,CAAnC,CAAA;AAA9B,GAAuB,CAAvB;;AACA,MAAMQ,WAAW,GAAG,SAAdA,WAAc,CAAA,GAAA,EAAS;AAC3B,QAAMC,QAAQ,GAAGP,GAAG,CAAHA,GAAAA,CAAjB,IAAiBA,CAAjB;;AACA,QAAI,CAAJ,QAAA,EAAe;AACb,aAAA,EAAA;AACD;;AAEDzB,IAAAA,KAAK,CAAA,QAAA,EAAW,UAAA,IAAA,EAAA,SAAA,EAAqB;AACnC,UAAI4B,IAAI,CAAR,QAAA,EAAmB;AACjBA,QAAAA,IAAI,CAAJA,SAAAA,GAAAA,CAAAA;AACAA,QAAAA,IAAI,CAAJA,OAAAA,GAAAA,CAAAA;AACA;AACD;;AAEDJ,MAAAA,SAAS,CAATA,OAAAA,CAAkB,UAAA,QAAA,EAAc;AAC9BE,QAAAA,QAAQ,CAARA,SAAAA,GAAqBO,IAAI,CAAJA,GAAAA,CAASP,QAAQ,CAAjBO,SAAAA,EAA6BL,IAAI,CAAtDF,SAAqBO,CAArBP;AACAA,QAAAA,QAAQ,CAARA,OAAAA,GAAmBO,IAAI,CAAJA,GAAAA,CAASP,QAAQ,CAAjBO,OAAAA,EAA2BL,IAAI,CAAlDF,OAAmBO,CAAnBP;AAFFF,OAAAA;AAPFxB,KAAK,CAALA;AAaA,WAAOgC,QAAQ,CAAf,QAAA;AAnBF,GAAA;;AAsBA,MAAME,MAAM,GAAG,GAAA,MAAA,CACbH,WAAW,CADE,OACF,CADE,EAEbA,WAAW,CAFE,OAEF,CAFE,EAGbA,WAAW,CAHE,OAGF,CAHE,EAIbD,QAAQ,GAAGA,QAAQ,CAAX,QAAA,GAJV,EAAe,CAAf;AAOAV,EAAAA,OAAO,CAAPA,KAAAA;AACAC,EAAAA,OAAO,CAAPA,KAAAA;AACAC,EAAAA,OAAO,CAAPA,KAAAA;AAEA,SAAA,MAAA;AACD;;AAED,SAAA,SAAA,CAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA8C;AAC5C,MAAMa,SAAS,GAAGC,MAAM,CAANA,SAAAA,IAAlB,kBAAA;AACA,SAAO;AACL1B,IAAAA,IAAI,EADC,SAAA;AAEL2B,IAAAA,OAAO,EAAED,MAAM,CAANA,SAAAA,IAFJ,KAAA;AAGLE,IAAAA,UAAU,EAAE,MAAM,CAAN,SAAA,GAAmB,MAAM,CAAN,MAAA,CAAA,EAAA,EAAA,OAAA,EAA2B;AAACH,MAAAA,SAAS,EAATA;AAAD,KAA3B,CAAnB,GAA6D;AAACA,MAAAA,SAAS,EAATA;AAAD,KAHpE;AAILhB,IAAAA,QAAQ,EAJH,QAAA;AAKLf,IAAAA,SAAS,EAAEgC,MAAM,CALZ,IAAA;AAMLxB,IAAAA,OAAO,EAAEO,QAAQ,CAACA,QAAQ,CAARA,MAAAA,GAATA,CAAQ,CAARA,CANJ,OAAA;AAOLoB,IAAAA,QAAQ,EAAE;AAPL,GAAP;AASD;;AAED,SAAA,SAAA,CAAA,SAAA,EAAA,OAAA,EAAA,OAAA,EAAgD;AAC9C,MAAIC,OAAO,CAAPA,MAAAA,KAAAA,CAAAA,IAAwBC,SAAS,CAATA,MAAAA,KAA5B,CAAA,EAAoD;AAClD,WAAA,SAAA;AACD;;AAED,MAAMC,GAAG,GAAG,OAAO,CAAP,MAAA,CAAe,UAAA,GAAA,EAAA,MAAA,EAAA;AAAA,WAAiBC,UAAU,CAACP,MAAM,CAAP,IAAA,EAA3B,GAA2B,CAA3B;AAAf,GAAA,EALkC,SAKlC,CAAZ,CAL8C,CAO9C;;AACA,MAAMQ,OAAO,GARiC,EAQ9C,CAR8C,CAU9C;;AACA,MAAIC,QAAQ,GAAZ,CAAA;;AACA,OAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGN,OAAO,CAA3B,MAAA,EAAoCM,CAApC,EAAA,EAAyC;AACvC,QAAMV,MAAM,GAAGI,OAAO,CADiB,CACjB,CAAtB,CADuC,CAGvC;;AACA,SAAK,IAAInC,IAAI,GAAGqC,GAAG,CAAnB,QAAmB,CAAnB,EAA+BrC,IAAI,IAAIA,IAAI,CAAJA,OAAAA,GAAe+B,MAAM,CAA5D,IAAA,EAAmE/B,IAAI,GAAGqC,GAAG,CAAC,EAA9E,QAA6E,CAA7E,EAA2F;AACzFE,MAAAA,OAAO,CAAPA,IAAAA,CAAAA,IAAAA;AALqC,KAAA,CAQvC;;;AACA,QAAMG,KAAK,GAAX,EAAA;;AACA,SAAK,IAAI1C,KAAI,GAAGqC,GAAG,CAAnB,QAAmB,CAAnB,EAA+BrC,KAAI,IAAIA,KAAI,CAAJA,OAAAA,KAAiB+B,MAAM,CAA9D,IAAA,EAAqE/B,KAAI,GAAGqC,GAAG,CAAC,EAAhF,QAA+E,CAA/E,EAA6F;AAC3FK,MAAAA,KAAK,CAALA,IAAAA,CAAAA,KAAAA;AAXqC,KAAA,CAcvC;;;AACA,QAAIA,KAAK,CAALA,MAAAA,GAAJ,CAAA,EAAsB;AACpBH,MAAAA,OAAO,CAAPA,IAAAA,CAAaI,SAAS,CAAA,KAAA,EAAA,MAAA,EAAtBJ,OAAsB,CAAtBA;AACD;AA7B2C,GAAA,CAgC9C;;;AACA,SAAOC,QAAQ,GAAGH,GAAG,CAArB,MAAA,EAA8B;AAC5BE,IAAAA,OAAO,CAAPA,IAAAA,CAAaF,GAAG,CAACG,QAAjBD,EAAgB,CAAhBA;AACD;;AAED,SAAA,OAAA;AACD;;AAED,SAAA,UAAA,CAAA,GAAA,EAAA,OAAA,EAAkC;AAChC,MAAMJ,OAAO,GAAG,OAAO,CAAP,OAAA,CAAA,GAAA,CACT,UAAA,MAAA,EAAA;AAAA,WAAaJ,MAAM,CAANA,IAAAA,GAAAA,MAAAA,GAAuB;AAACa,MAAAA,IAAI,EAAEb;AAAP,KAApC;AADS,GAAA,EAAA,IAAA,CAER,UAAA,KAAA,EAAA,KAAA,EAAA;AAAA,WAAkBc,KAAK,CAALA,IAAAA,GAAaC,KAAK,CAApC,IAAA;AAFR,GAAgB,CAAhB;AAIA,MAAMC,QAAQ,GAAGtC,aAAa,CAAbA,GAAa,CAAbA,CAAjB,KAAA;AACA,SAAOuC,SAAS,CAAA,QAAA,EAAA,OAAA,EAAhB,OAAgB,CAAhB;AACD;;AAEDC,MAAM,CAANA,OAAAA,GAAAA,UAAAA","sourcesContent":["const filter = require('unist-util-filter')\nconst visit = require('unist-util-visit-parents')\nconst NodeMap = require('./map')\n\nfunction lineNumberify(ast, context = {lineNumber: 1}) {\n  return ast.reduce(\n    (result, node) => {\n      const lineStart = context.lineNumber\n\n      if (node.type === 'text') {\n        if (node.value.indexOf('\\n') === -1) {\n          node.lineStart = lineStart\n          node.lineEnd = lineStart\n          result.nodes.push(node)\n          return result\n        }\n\n        const lines = node.value.split('\\n')\n        for (let i = 0; i < lines.length; i++) {\n          const lineNum = i === 0 ? context.lineNumber : ++context.lineNumber\n          result.nodes.push({\n            type: 'text',\n            value: i === lines.length - 1 ? lines[i] : `${lines[i]}\\n`,\n            lineStart: lineNum,\n            lineEnd: lineNum,\n          })\n        }\n\n        result.lineNumber = context.lineNumber\n        return result\n      }\n\n      if (node.children) {\n        const processed = lineNumberify(node.children, context)\n        const firstChild = processed.nodes[0]\n        const lastChild = processed.nodes[processed.nodes.length - 1]\n        node.lineStart = firstChild ? firstChild.lineStart : lineStart\n        node.lineEnd = lastChild ? lastChild.lineEnd : lineStart\n        node.children = processed.nodes\n        result.lineNumber = processed.lineNumber\n        result.nodes.push(node)\n        return result\n      }\n\n      result.nodes.push(node)\n      return result\n    },\n    {nodes: [], lineNumber: context.lineNumber}\n  )\n}\n\nfunction unwrapLine(markerLine, nodes) {\n  const tree = {type: 'root', children: nodes}\n\n  const headMap = new NodeMap()\n  const lineMap = new NodeMap()\n  const tailMap = new NodeMap()\n  const cloned = []\n\n  function addCopy(map, node, ancestors) {\n    cloned.push(node)\n\n    ancestors.forEach((ancestor) => {\n      if (!map.has(ancestor)) {\n        map.set(ancestor, Object.assign({}, ancestor, {children: []}))\n\n        if (ancestor !== tree) {\n          cloned.push(ancestor)\n        }\n      }\n    })\n\n    let i = ancestors.length\n    while (i--) {\n      const ancestor = map.get(ancestors[i])\n      const child = ancestors[i + 1]\n      const leaf = map.get(child) || node\n      if (ancestor.children.indexOf(leaf) === -1) {\n        ancestor.children.push(leaf)\n      }\n    }\n  }\n\n  visit(tree, (node, ancestors) => {\n    if (node.children) {\n      return\n    }\n\n    // These nodes are on previous lines, but nested within the same structure\n    if (node.lineStart < markerLine) {\n      addCopy(headMap, node, ancestors)\n      return\n    }\n\n    // These nodes are on the target line\n    if (node.lineStart === markerLine) {\n      addCopy(lineMap, node, ancestors)\n      return\n    }\n\n    // If we have shared ancestors with some of the cloned elements,\n    // create another tree of the remaining nodes\n    if (node.lineEnd > markerLine && cloned.some((clone) => ancestors.indexOf(clone) !== -1)) {\n      addCopy(tailMap, node, ancestors)\n    }\n  })\n\n  // Get the remaining nodes - the ones who were not part of the same tree\n  const filtered = filter(tree, (node) => cloned.indexOf(node) === -1)\n  const getChildren = (map) => {\n    const rootNode = map.get(tree)\n    if (!rootNode) {\n      return []\n    }\n\n    visit(rootNode, (leaf, ancestors) => {\n      if (leaf.children) {\n        leaf.lineStart = 0\n        leaf.lineEnd = 0\n        return\n      }\n\n      ancestors.forEach((ancestor) => {\n        ancestor.lineStart = Math.max(ancestor.lineStart, leaf.lineStart)\n        ancestor.lineEnd = Math.max(ancestor.lineEnd, leaf.lineEnd)\n      })\n    })\n\n    return rootNode.children\n  }\n\n  const merged = [].concat(\n    getChildren(headMap),\n    getChildren(lineMap),\n    getChildren(tailMap),\n    filtered ? filtered.children : []\n  )\n\n  headMap.clear()\n  lineMap.clear()\n  tailMap.clear()\n\n  return merged\n}\n\nfunction wrapBatch(children, marker, options) {\n  const className = marker.className || 'refractor-marker'\n  return {\n    type: 'element',\n    tagName: marker.component || 'div',\n    properties: marker.component ? Object.assign({}, options, {className}) : {className},\n    children,\n    lineStart: marker.line,\n    lineEnd: children[children.length - 1].lineEnd,\n    isMarker: true,\n  }\n}\n\nfunction wrapLines(treeNodes, markers, options) {\n  if (markers.length === 0 || treeNodes.length === 0) {\n    return treeNodes\n  }\n\n  const ast = markers.reduce((acc, marker) => unwrapLine(marker.line, acc), treeNodes)\n\n  // Container for the new AST\n  const wrapped = []\n\n  // Note: Markers are already sorted by line number (ascending)\n  let astIndex = 0\n  for (let m = 0; m < markers.length; m++) {\n    const marker = markers[m]\n\n    // Start by eating all AST nodes with line numbers up to the given marker\n    for (let node = ast[astIndex]; node && node.lineEnd < marker.line; node = ast[++astIndex]) {\n      wrapped.push(node)\n    }\n\n    // Now proceed to find all _contiguous_ nodes on the same line\n    const batch = []\n    for (let node = ast[astIndex]; node && node.lineEnd === marker.line; node = ast[++astIndex]) {\n      batch.push(node)\n    }\n\n    // Now add that batch, if we have anything\n    if (batch.length > 0) {\n      wrapped.push(wrapBatch(batch, marker, options))\n    }\n  }\n\n  // Now add the remaining AST nodes\n  while (astIndex < ast.length) {\n    wrapped.push(ast[astIndex++])\n  }\n\n  return wrapped\n}\n\nfunction addMarkers(ast, options) {\n  const markers = options.markers\n    .map((marker) => (marker.line ? marker : {line: marker}))\n    .sort((nodeA, nodeB) => nodeA.line - nodeB.line)\n\n  const numbered = lineNumberify(ast).nodes\n  return wrapLines(numbered, markers, options)\n}\n\nmodule.exports = addMarkers\n"]},"metadata":{},"sourceType":"script"}